* 요약 : 추상화의 한 방법인 분해의 역사. 기능 분해~객체지향까지 sw 패러다임 변화 이해.

* 추상화 : 불필요한 정보 제거, 현재 문제 해결에 필요한 핵심만 남기기
* 분해 : 큰 문제 -> 해결 가능한 작은 문제

# 1. 프로시저 추상화와 데이터 추상화
* 프로시저 추상화 : sw 가 무엇을 해야하는지 추상화
	* 기능 분해 / 알고리즘 분해
* 데이터 추상화 : sw 가 무엇을 알아야 하는지 추상화
	* 추상 데이터 타입 : 타입을 추상화 
	* 객체지향 : 프로시저를 추상화

# 2. 프로시저 추상화와 기능 분해
* 메인 함수로서의 시스템
	* 하향식 접근법
	* 문제점
		* 시스템은 하나의 메인함수 x
		* 기능 추가 및 요구사항 변경으로 빈번한 수정
		* 비즈니스 로직이 사용자 인터페이스와 강결합
		* 유연성 재사용성 저하
		* 데이터 형식 변경시 파급효과 예측 불가

# 3. 모듈
* 정보 은닉 : 시스템을 모듈 단위로 분해하려면 자주 변경되는 부분을 덜 변경되는 안정적 인터페이스 뒤로 감춰야 한다.
* 시스템을 모듈로 분해 후 모듈 내부 구현 위해 기능 분해 적용.

* 모듈이 감춰야할 비밀
	* 복잡성 : 모듈 너무 복잡하면 이해하고 사용하기 어려움
	* 변경 가능성 : 변경 간의 설계 외부 노출시 실제 변경시 파급효과 커짐
* 모듈의 장점과 한계
	* 장점
		* 모듈 내부 변수 변경되도 모듈 내부에만 영향.
		* 비즈니스 로직과 사용자 인터페이스에 대한 관심사 분리.
		* 전역 변수와 전역 함수 제거함으로 네임 스페이스 오염 방지.
	* 단점
		* 인스턴스 개념을 제공하지 않음.

ex. 다수 직원 인스턴스가 존재하는 추상화 메커니즘 필요.

# 4. 데이터 추상화와 추상 데이터 타입
* 추상 데이터 타입 
	* 추상 객체의 클래스 정의한 것으로 추상 객체에 사용할 수 있는 오퍼레이션 이용해 규정.
	* 사용시, 프로그래머는 객체가 외부에 제공하는 행위에만 관심, 행위가 구현되는 세부 사항에 대해서는 무시.

# 5. 클래스
* Q. 클래스는 추상 데이터 타입인가?
	* 동일하지 않다
	* 클래스 : 상속 + 다형성 지원 : 절차를 추상화한 것 : 타입 기준으로 오퍼레이션 묶음.
	* 추상 데이터 타입(ADT) : X  : 타입을 추상화한 것 : 오퍼레이션 기준으로 타입 묶음.

* 변경을 기준으로 선택하라
	* 타입 기준으로 절차 추상화하지 않았다면 객체지향 분해가 아님.
	* 클래스가 추상 데이터 타입 따르는지 확인하는 방법 `클래스 내부 인스턴스 타입 표현하는 변수 있는지 확인`

	* 객체 지향 사용할 때
		* 타입 추가 변경 압력이 강할 때
	* 추상 데이터 타입 사용할 때
		* 오퍼레이션 추가시
	* 협력이 중요~!
		* 객체지향 중요한 건 역할, 책임, 협력 -> 책임 주도 설계
		* 객체가 참여할 협력 결정 -> 협력에 필요한 책임 수행 위해 필요한 객체 고민 -> 책임을 다양한 방식으로 수행해야 할 때 타입 계층 안에서 절차 추상화 

> 데이터 주도 설계
> 추상 데이터 타입의 접근법을 객체지향 설계에 구현한 것.
 
