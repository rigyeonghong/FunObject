- 작고 응집도 높은 객체 =책임의 초점이 명확하고 한가지 일만 잘하는 객체
- 과도한 협력은 다른 객체를 알 것을 강요하고 이것이 의존성을 낳는다
- 의존성은 수정을 어렵게 만듬
- 충분히 협력적이면서도 유연한 객체를 만들기 위해 의존성 관리

[의존성 이해하기]

- **의존성 : 객체가 협력하기 위해 다른 객체를 필요로 할 때 발생**
    - 실행시점 의존성= 실행 시에 의존대상 객체가 **있어야함**
    - 구현시점 의존성 =  의존대상 객체가 변경되는 경우 의존객체도 **함께 변경**
    - 의존성은 방향을 가지며 **단방향**
        - A- - - >B A가 B에 의존한다
    - UML에서의 의존관계와는 조금 다름

- **의존성 전이** : 의존대상의 의존대상을 자동으로 의존,  **함께 변경될 가능성**
    - **직접의존성**:  다른요소에 직접의존
    - **간접의존겅** : 직접관계는 아니지만 의존서이 전의에 의해 영향이 **전파된 경우**
    - 의존하는 객체의 전부가 전이된는것은 아님, 캡슐화가 잘 된경우 변경 전파가 적음
- 런타임 의존성과 컴파일타임 의존성
    - **런타임 : 실행시점, 객체** 메인
    - **컴파일타임 : 코드 그 자체** (보통은 작성된 코드를 컴파일하는 시점, 동적타입언어의 경우 애매하기 때문), **클래스** 메인
    - 둘은 다를 수 있음
        - 실행 시점에는 의존객체 하위 내용도 알아야함, 실제로 협력할 객체가 어떤건지는 런타임에 해결
        - 실행구조와 소스코드구조가 멀수록 설계가 유연
- **컨텍스트 독립성** : 클래스가 사용될 특정 문맥에 대해 **최소한의 가정만 가짐**, 재사용성 상승
    - 구체적인 클래스를 알 수록 특정 문맥에 강하게 결합됨
- **의존성 해결 : 컴파일타임 의존성은 구체적인 런타임 의존성으로 대체**
    - 객체를 생성하는 시점에 생성자를 통해 해결
    - 객체 생성 후 세터를 통해 해결
    - 메서드 실행 시 인자를 이용해 해결 ← 변경에 유연, but 생성시점에 객체가 불안정

[유연한 설계]

사용과 생성 로직 분리, 의존성의 생성자에 명시(명시적인 의존성), 구체클래스가 아닌 추상클래스나 인터페이스에 의존(추상화)

유연하고 재사용 가능한 설계는 객체가 어떻게 하는지 나열하지 않고도 객체들의 **조합을** 통해 waht 무엇을 하는지 표현하는 클래스로 구성되어 코드만 보고도 파악이 쉽다.

- 의존성과 결합도
    - **바람직한 의존성** :  다양항 환경에서 재사용 가능함 = 컨텍스트독립적 = 느슨한결합도를 가집
    - 의존성이 다양항 환경에서 클래스를 재사용할 수 없도록 제한하면 안됨, 강한결합도를 가지게됨
    - 결합도 : 의존성의 정도 , 의존성은 유무를 표현
- 지식이 결합을 낳는다
    - 객체가 **서로에 대해 알고있는 지식 만큼 결합도가 증가**
- 추상화에 의존하라
    - **추상화를** 통해 협력하는 대상에 대해 적게 알게함
    - 구체 클래스 의존성 > 추상 클래스 의존성 >인터페이스 의존성
- 명시적인 의존성
    - 추상 타입에 구체적인 인스턴스를 생성해서 대입하면 구체 클래스에 의존하게 됨
    - 의존성 해결방법으로 의존성을 해결해야함
    - **명시적인 의존성** : 인자로 전달받게 되면(생성자, 세터) **의존사실을 퍼플릭 인터페이스에 노출**하게 됨
    - 내부에서 인스턴스를 직접 생성하는 방식은 의존사실을 감추기 때문에 **숨겨진 의존성** (퍼블릭 인터페이스에 의존성이 표현되지 않음)
        - 바로 파악이 가능하고, 재사용할수 있게 병경이 용이하도록 구현에 숨겨두지 마라
- new는 해롭다 →결합도가 높아짐
    - 구체 클래스의 이름을 기술해야 하기 떄문에 추상화가 안되고 구체 클래스에 의존함
    - 어떤 인자로 생성자를 호출해야하는지도 알아야해서 알아야하는 지식이 늘어남
    - **인스턴스 생성 로직과 사용로직 분리**해야함
    - 가끔은 생성해도 무방하다→ 주로 사용하는 객체가 정해진 경우 명시적인 의존성을 가진 생성자를 따로 두어 사용성증대
- 표준 클래스에 대한 의존은 해롭지 않다
    - 의존성은 변경에 대한 영향때문에 불편하지만 표준클래스는 변경이 적기때문에 의존해도 괜찮음 (ArrayList 등)
- 컨텍스트 확장하기
    - 예외 케이스로 만들지 말고 자식클래스를 새로 생성( 할인정책이 없는경우, 여러 할인정책을 갖는 경우)
