- 상속의 목적은 코드 재사용이 아닌 타입계층 구조화.(서브타입계층구축) 타입 계층이 객체지향 프로그래밍의 중요 특성인 다형성의 기반을 제공. ( 다른방법으로도 다형성 구현 가능)
    - 인스턴스들을 동일하게 행동하는 그룹으로 묶기 위함
    - 다형성은 런타임에 메세지를 처리하기 적합한 메서드를 동적으로 탐색하는 과정을 통해 구현, 상속은 이런 탐색 경로를 클래스 계층의 형태로 구현하기위한 방법

## [다형성]

- 다형성 (polymorphism) : 하나의 추상 인터페이스에 대해 코드를 작성하고, 이 인터페이스에 대해 서로 다른 구현을 연결할 수 있는 능력 = 여러타입을 대상으로 동작할수 있는 코드작성 방법
- 종류 :
    - 유니버설
        - **매개변수** :  클래스의 인스턴스 변수나 메서드의 매개변수 타입을 임의로 선언한 후 사용하는 시점에 구체적인 타입으로 지정하는방식 ( 제네릭 프로그래밍), 여러타입의 요소를 다루는데 동일한 오퍼레이션 사용 가능
        - **포함** : 메세지가 동일하더라도 수신한 객체의 타입에 따라 실제로 수행되는 행동이 달라지는 능력 (서브타입다형성) , 얘가 디폴트임
            - 포함 다형성을 구현하는 가장 일반적인 방법이 상속, 오버라이딩하여 부모클래스만 참조, 자식이 부모클래스의 서브타입이여야함.
            - 상속을 사용하는 이유는 상속이 클래스들을 계층으로 쌓아 올린 후 상황에따라 적절한 메서드를 선택할 수 있는 메커니즘을 제공하기 때문. 객체가 메세지를 수신하면 메시지를 처리할 적절한 메서드를 상속 계층안에서 탐색함
    - 임시
        - **오버로딩** : 하나의 클래스안에 동일한 이름의 메서드가 존재하는 경우 , 이름 통일가능
        - **강제** : 언어가 지원하거나 직접구현한 타입변환을 이용해 동일한 연산자를 다양항 타입에 사용
        - 강제+오버로딩 함꼐 사용지 어떤 메서드가 호출될지 판단하기가 어려워짐

## [상속의 양면성]

- 객체지향 핵심 아이디어 : **데이터와 행동을 객체라고 불리는 하나의 실행단위 안**으로 통합
    - 상속은 데이터 관점에서 부모클래스의 모든 데이터를 자식에게 포함 가능 , 행동관점에서는 메서드 포함 가능 → 상속은 재사용을 위함? →X, 다형성을 위한 타입계층 구축을 위함
    - 업캐스팅/동적메서드탐색/동적바인딩/self참조/super참조
- 강의 성적 계산 예제
    - 두 시그니처가 동일한 메서드의 경우 자식클래스의 우선순위가 높다(실행된다) = **메서드  오버라이딩** = 상속받을 메서드와 동일한 시그니처의 메서드를 재정의해서 부모클래스의 구현을 새로운 구현으로 대체
    - **메서드 오버로딩** : 부모클래스에서 정의한 메서드와 이름은 동일하지만 시그니처는 다른 메서드를 자식클래스에 추가
- 데이터 관점의 상속
    - **자식 클래스의 인스턴스 안에 부모 클래스의 인스턴스를 포함**. ( 자식클래스에서 부모클래스의 인스턴스로 접근가능한 링크가 생기는 것처럼~)
- 행동 관점의 상속
    - 부모클래스가 정의한 일부 메서드를 자식 클래스의  메서드로 포함
    - 객체의 경우 인스턴스별로 독립적인 메모리를 할당받아야하지만 메서드의 경우에는 동일한 **클래스의 인스턴스끼리 공유**가 가능하기때문에 한번만 메모리에 로드하고 각 인스턴스별로 클래스를 가르키는 포인터를 갖게함 (인스턴스는 여러개, 클래스는 한번만 로드)
    - 코드가 합쳐지거나 복사되는것이 아닌 런타임에서 시스템이 자식클래스에 정의되지않은 메서드가 있는 경우 **부모클래스안에서 탐색**

## [업캐스팅과 동적 바인딩]

- **업캐스팅**: 부모클래스 타입의 변수에 자식 인스턴스를 할당 가능
    - 대입문, 메서드의 파라미터 타입으로 활용
    - **다운캐스팅** :부모를 자식으로 변환하기 위해서는 타입캐스팅이 필요함
- **동적 바인딩** : 선언된 변수의 타입이 아닌 **메세지를 수신하는 객체의 타입에 따라 실행되는 메서드가 결정**, 메세지를 처리할 메서드를 실행시점에 결정하기 때문에 가능 =지연바인딩
    - 객체지향에서 메세드 실행하는 방법은 메시지를 전송하는것. 전통언어는 함수실행방식이 함수호출.
    - 함수호출방식은 호출될 함수를 컴타일 타입에 결정 = **정적바인딩**=초기바인딩=컴파일타임바인딩
- 코드안에서 선언된 참조타입과 무관하게 실제로 메세지를 수신하는 객체의 타입에 따라 실행되는 메서드가 달라짐 → 업캐스팅&동적바인딩
    - 개방 폐쇄 원칙의 의도와 유사 ( 코드를 변경하지 않고도 기능 추가 가능, 유연하고 확장가능한 코드를 위해 의존관계를 구조화하는 방법)

## [동적메서드 탐색과 다형성]

- java등 정적타입에서 this가 self에 해당됨. 루비 등 동적 언어는 self를 그대로 사용
- **동적 메서드 탐색 → 자동적인 메시지 위임 & 동적인 문맥**
    - **자동적인 메시지 위임** : 이해할수 없는 메시지를 받은 경우 **부모클래스에 처리 위임**
        - 실행할 메서드 선택 : 메세지를 수신한 객채는 먼저 자신을 생성한 클래스에 메서드가 있는지 검사 → 부모클래스에서 계속 상속계층을 따라 올라가며 진행 → 최상위까지 없으면 예외를 발생시키며 탐색 종료
        - 오버라이딩은 부모클래스의 메서드를 감추게됨, 오버로딩은 사이좋게 공존(모든메서드 호출가능) , c++ 의경우 이름숨기기 ( 혼란방지를 위해 부모클래스의 동일한 이름의 메서드는 숨김,자식에서 전부 오버로딩하거나 네임스페이스에 합침)
    - **동적인 문맥 사용** : 메시지 수신 시  실행될 메서드는 컴파일이 아닌 **실행시점**,경로를 self 참조 이용하여 결정
        - **self 참조** : 객체가 메시지를 수신하면 컴파일러는 self 참조라는 임시변수를 자동으로 생성한 후 메세지를 수신한 객체를 가르키도록 설정. 동적 메서드 탐색은 self가 가르키는 객체의 클래스에서 시작되고 탐색이 끝나면 자동으로 소멸 ( class포인터 + parent포인터 +self참조)
        - **self호출** = 자신에게 다시 메시지를 전송. 현재 객체에게 메시지를 전송하는것. 즉 s**elf가 가리키는 그 객체부터 메시지 탐색**을 다시 시작한다
- 이해할 수 없는 메세지
    - 정적타입 : 컴파일 시에 판단. 컴파일에러를뱉음. 안정적이지만 유연성 부족
    - 동적타입 : 실행하기 전에 판단 불가능.
        - 루비는 method_missing 메시지전송하ㅣ여 NoMethod예외 발생 등.
        - 해당 메시지에 응답할 수 있는 메서드를 구현 할 수 도 있다→ 조금더 순수한 객체지향(메시지를 전송하는 객체는 메시지를 수신한 객체의 내부를 모름), 선언과 구햔 분리 but 코드가 어렵고 디버깅이 복잡
- self & super
    - super 참조를 통해 메시지를 전송. 메서드 호출보다는 전송( 더 조상의 메서드를 호출하게 될수도 있음) = 이 클래스의 부몸클래스부터 탐색을 시작하세요
    - self는 메시지를 수신하는 객체에 따라 시작위치가 동적, super는 부모로 고정(컴파일시점에, 언어에따라서 런타임일수도있음)

## [상속 대 위임]

- 위임과 self참조
    - self는 메시지를 수신한 객체 기준이기 때문에 안에 포함된 부모 인스턴스 기준으로도 자식이 될수있음. 메서드 탐색중에는 부모자식이 동일한 self 참조 공유
    - **위임** : 자신이 수신한 메시지를 **다른 객체에게 동일하게 전달해서 처리를 요청**, 이를 위해 위임은 항상 현재의 실행 문맥을 가리키는 self참조를 인자로전달.
    - 포워딩 vs 위임 : self를 전달하지 않는경우. 단순히 **코드를 재사용**하고 최초의 객체에게 다시 메시지를 전송할 필요 없는 경우←**포워딩** / 위임은 **상속관계를 객체사의의 합성관계로 대체해서 다형성을 구현하는것**
    - 상속은 자식클래스로 선언함으로서 self 참조가 자동으로 전달된다.. 그래서 상속은 자동적인 메시지 위임. (메시지 탐색을 위해 self참조를 자동으로전달) = 메세지 위임 자동 처리
- 프로토타입 기반의 객체지향 언어
    - 클래스가 아닌 객체를 이용해서도 상속을 흉내낼수있음, 객체사이의 위임 이용 ⇒ 상속이의외 방법으로 다형성 구현
    - 다른 객체를 가르키는 용도로 사용되는 프로토타입이라는 이름의 링크를 가짐, 자바스크립트에서 별다른 처리없이는 obect, prototype에 new Lecture를 통해 할당 가능
 
## 질문


Q1. 다형성의 기반이 된 개념이 뭔가용?

- 상속의 목적은 코드 재사용이 아닌 타입계층 구조화.(서브타입계층구축) 타입 계층이 객체지향 프로그래밍의 중요 특성인 다형성의 기반을 제공.

Q1-1. 보통 다형성을 말할 때 어떤 다형성을 뜻하는지와 , 그 외의 종류를 알고있다면 설명해주세요

- **포함** : 메세지가 동일하더라도 수신한 객체의 타입에 따라 실제로 수행되는 행동이 달라지는 능력 (서브타입다형성)

Q3 귀여운질문.. 메서드 오버라이딩과 오버로딩을 설명해주세요

- **메서드  오버라이딩** = 상속받을 메서드와 동일한 시그니처의 메서드를 재정의해서 부모클래스의 구현을 새로운 구현으로 대체
- **메서드 오버로딩** : 부모클래스에서 정의한 메서드와 이름은 동일하지만 시그니처는 다른 메서드를 자식클래스에 추가

Q4. 상속에서 자식클래스에서 다시 정의하지 않은 부모 메서드를 어떤 방식으로 찾아서 실행시키는지 설명해주세요 (키워드도 말하면 좋아용, 동적인 메서드 참조)

- 코드가 합쳐지거나 복사되는것이 아닌 런타임에서 시스템이 자식클래스에 정의되지않은 메서드가 있는 경우 부모클래스안에서 탐색 (자동적인 메세지위임), 없는경우 에러를 반환한다
- self를 통해 경로를 결정

Q4-1. 상속을 통해 어떻게 메모리를 절약할 수 있는지 설명해주세요

- (인스턴스는 여러개, 클래스는 한번만 로드) 401p 참고!

Q4-2: self와 super의 동작이 어떻게 다를까요?

- self는 메시지를 수신하는 객체에 따라 시작위치가 동적, super는 부모로 고정(컴파일시점에, 언어에따라서 런타임일수도있음)

Q5: 업캐스팅이 뭔지 설명해주세요.

- 부모클래스 타입의 변수에 자식 인스턴스를 할당 가능

Q5-1 다운캐스팅은 어떻게 가능할까요?

- 부모를 자식으로 변환하기 위해서는 타입캐스팅이 필요함
