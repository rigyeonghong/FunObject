- 이번장은 올바를 타입 계층을 구서하는 원칙을 살펴보기로 함
    - 동일한 메ㅔㅅ지에 서로 다르게 행동할 수 있는 다형적인 객체를 구현하기 위해서는 객체의행동을 가반으로 타입 계층을 구성해야한다.
- 상속은 두가지 용도로 사용됨
    - 타입계층 구현 ( 부모(일반화) ↔ 자식(특수화)) < 1차목표는 얘가 되어야함
    - 코드 재사용 ( 부모 재사용 가능 but 강하게결합)
- 객체기반 프로그래밍: 상태와 행동을 캡슐화한 객체를 조합해서 프로그램을 구성하는 방식, 객체지향이 하위
    - 객체지향은 객체들을 조합하지만 상속과 다형성을 지원한다는 점에서 차별화.
    - 다른 관점으로는 프로토타입 기반 (클래스없는) 언어라는 관점도 쓰임

## [타입]

- 타입이란 ?
    - 개념 관점 : 세상 사물의 종류, 개념이나 아이디어
        - 어떤 대상이 타입으로 분류될떄 그 대상을 **인스턴스**라고함. 보통 **객체**라고 부름
        - 심볼 : 타입에 이름을 붙인것
        - 내연 : 타입의 정의 , 타입에 속하는 객체들의 공통적인 속성이나 행동
        - 외연 : 타입에 속하는 객체들의 집합
    - 프로그래밍 언어 관점 : 연속적인 비트에 의미를 부여하기해 정의된 제약과 규칙.
        - 비트에 담긴 데이터를 무엇으로 다룰지는 어플맄네이션에 의해 결정됨.
        - 타입에 수행될 수 있는 유효한 오퍼레이션의 집합 정의 (연산자제한)/ 수행되는 오퍼레이션에 대해 미리 약속된 문맥제공 (행동정의) 두가지 목적을 위해 사용됨
        - 적용가능한 오퍼레이션의 종류와 의미를 정의하여 코드의 의미를 명확하게 전달하고 실수를 방지
    - 객체지향 패러다임 관점 :  공통의 특징을 공유하는 대상들의 분류(개념관점)+동일한 오퍼레이션을 적용할 수 있는 인스턴스의 집합(프로그래밍관점) ← **퍼블릭인터페이스**(객체가 수신할 수 있는 메시지의 집합)
        - 객체의 퍼블릭 인터페이스가 객체의 타입을 결정. 따라서 동일한 퍼블릭 인터페이스를 제공하는 객체는 동일한 타입
        - 중요한것은 행동이라는것이 강조됨 (내부의 속성이 아닌 외부에 제공하는 행동!)

## [타입 계층]

- 타입이 다른 타입에 포한될수 있기때문에 동일 인스턴스가 하나 이상의 타입으로 분류되는것이 가능.
- **슈퍼타입** : 더 일반적인 타입, 보편적이고 추상적으로(내연)
    - 집합이 다른 집합의 모든 멤버를포함/ 정의가 좀더 일반적
    - 서비타입이 정의한 퍼블릭ㅌ인터페이스를 일반화 시켜 범용저깅로 넓게 정의
- **서브타입** : 더 특수한 타입, 구체적이고 문맥종속적으로(내연)
    - 집합에 포함되는 인ㅅ그턴스들이 더 큰 집합에 포함됨/ 정의가 좀더 구체적
    - 슈퍼타입이 정의한 퍼블릭 인터페이스를 구체적이고 좁은 의미로 정의

## [서브클래싱과 서브타이핑]

- 타입을 구현하는 일반적인 방법은 클래스이용, 타입계층을 구형하는 일반적인 방법은 상속
- 상속을 사용하는 경우 두가지 만족
    - is-a 관계를 모델링하는가?
        - 타입 S는 타입 T 다 (S is T) 라고 말할 수 있어야 함 (but 행동관점에서 불일치할수있어서 아래의 조건을 만족해야함)
    - 클라이언트 입장에서 부모클래스의 타입으로 자식클래스를 사용해도 무방한가?
        - 상속 계층을 사용하는 클라이언트의 입장에서 부모클래스와 자식클래스의 차이점을 몰라야한다( **행동호환성**),
        - 클라이언트 관점에서 행동의 호환 여부를 판단
        - bird 밑에 ㄴflyingbird와 펭귄을 가지는 ㅡ방법과 클라이언트에 따라 인터페이스를 분리하는 방법 사용 가능,
        - 재사용하고 싶은 경우 합성을이용하는것이 더 좋긴 함 ( 재사용을 위해상속을 껴안고 가기보단)
        - **인터페이스 분리 원칙** : 클라이언트의 기대에 따라 인터페이스를 분리하여 영향을 제어하는 설계 원칙\
        - 자연어에 현혹되지 말고 요구사항속에서 클라이언트가 기대한느 행동에 집중할것.
    - 서브클래싱 : 재사용 목적의 상속 (= 구현상속,클래스상속)
        - 자식과 부모의 행동이 호환디지 않기떄문에 대체 불가능
    - 서브타이핑 : 타입계층목적의 상속 (=인터페이스 상속)
        - 자식클래스의 인스턴스가 부모클래스의 인스턴스 대체 가능
        - 슈퍼타입의 퍼블릭인터페이스를 상속
        - 행동호환성 만족(부모의 모든행동을 동일하게 할 수 있어야한) = 대체가능성 포함
    

---

## [질문]

Q1.  상속의 용도를 설명해주세요.

- 타입계층 구현 ( 부모(일반화) ↔ 자식(특수화)) < 1차목표는 얘가 되어야함
- 코드 재사용 ( 부모 재사용 가능 but 강하게결합)

Q2. 타입을 개념,프로그래밍언어, 객체지향 관점에서 설명해주세요

- 개념 관점 : 세상 사물의 종류, 개념이나 아이디어
- 프로그래밍 언어 관점 : 연속적인 비트에 의미를 부여하기해 정의된 제약과 규칙.
- 객체지향 패러다임 관점 :  객체의 퍼블릭 인터페이스가 객체의 타입을 결정. 따라서 동일한 퍼블릭 인터페이스를 제공하는 객체는 동일한 타입

Q3. 상속을 사용하는 경우는 어떤 케이스가 있을까요?

- is-a 관계를 모델링하는가?
- 클라이언트 입장에서 부모클래스의 타입으로 자식클래스를 사용해도 무방한가?
- 를 만족하는 케이스
