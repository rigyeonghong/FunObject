- 인지과부하 - 문제 해결에 필요한 요소의 수가 단기 기억의 용량을초과하여 문제해결 능력이 떨어지는 현상
- 추상화 - 정보의 수를 줄이기 위해 불필요한 정보를 제거하고 현재의 문제해결에 필요한 핵심만 님김
- 분해 - 큰 문제를 해결가능한 작은 문제로 나눔
    - 큰 문제를 인지 과부하의 부담없이 단기 기억안에서 한번에 처리할 수 이쓴ㄴ 규모로 나눔

[프로시저 추상화와 데이터 추상화]

- 고수준언어 - 기계적인 사고를강요하는 낮은 수준의 명령어들을 인간의 눈높이에 맞는 기계독립적인 의미있는 추상화
- 프로그래밍 패러다임 - 적절한 추상화의 윤곽을 따라 시스템을 어떤식으로 나눌것인지 결정하는 원칙과 방법들
- 프로시저 추상화 : 소프트웨어가 무엇을 해야하는지를추상화
    - 기능 분해 = 알고리즘분해 : 프로시저 추상화를 중심으로 시스템을 분해
- 데이터 추상화 : 소프트웨어가 무엇을 알아야하는지를 추상화
    - 추상 데이터 타입 : 데이터를 중심으로 타입을 추상화
    - 객체지향 : 데이터를 중심으로 프로시저를 추상화 → 기능을 협력하는 공동체를 구성하도록 객체들로 나누는 과정이 분해임(역할과 책임을 수행하는 객체)

[프로시저 추상화와 기능 분해]

- 알고리즘분해( 기능분해) -기능을 기준으로 시스템을 분해
- 추상화 단위는 프로시저, 시스템은 프로시저를 단위로 분해된다
- 프로시저 : 반복적으로 실행되거나 유사하게 실행되는 작업을 모아 재상요하고 중복을 방지하는 추상화기법
    - 내부의 상세한 구현내용을 모르더라도 인터페이스르 ㄹ알면 프로시저를 사용가능하기 떄문에 추상화(정보은닉)
- 하향식 접근법 : 최상위기능을 정의하고 작은단위로 분해
    - 하나의 메인 함수라는 비현실적 아이디어 (작은 시스템이나 시스템이 아닌 하나의 알고리즘이나배치에 적합 )
    - 메인 함수의 빈번한 재설계- 변경에 취약
    - 비즈니스 로직이 사용자 인터페이스와 강하게 결합 - 인터페이스는 빈번하게 변경되는데 섞어여있어서 변경에 불안정함.. 관심사의 분리 필요
    - 함수의 실행순서 고정 - 무엇이 아닌 어떻게에 집중하게 만듬, 시간제약(실행순서)가 강조됨, 중앙집중제어 스타일이 됨, 강하게 결합 → 시간제약이 아닌 논리적제약을 설계의 기준으로 삼아야 안정적이됨
    - 데이터 형식이 변경될 경우 파급효과 예측 불가 - 어떤 데이터를 어떤 함수가 사용하고 있는지 추적하기 어려워서 파급효과도 예측하기 어려움 → 변경에 대한 영향을 최소화하기 위해 데이터와 함꼐 변경되는 부분과 아닌부분 명확히 분리하고 외부에는 퍼블릭인터페이스만 제공 →정보은닉과 모듈
- 기능을 중심으로 필요한 데이터를 결정→ 유지보수에 문제

[모듈]

- **정보은닉** : 시스템을 모듈 단위로 분해하기 위한 기본원리, 자주 변경되는 부분을 상대적으로 덜 변경되는 안정적인 인터페이스 뒤로 감추자
- 모듈은 변경될 가능성이 있는 비밀을 내부로 감추고 , 잘 변경되지않는 퍼블릭 인터페이스를 외부에제공하여 비밀에 접근하지 못하도록 한다
    - 기능이 아닌 변경의 정도의 따라 시스템을 분해
    - 시스템을 모듈로 분해한 후에는 각 모듈 내부를 구현하기 위해 기능 분해 적용 가능
    - 모듈에 숨기는 비밀
        - 복잡성: 모듈을 쉽게 사용하도록 간단한 인터페이스를 제공하여 모듈의 복잡도를 낮춤
        - 변경가능성 : 변경시 하나의 모듈만 수정하면 되도록 변경가능한 설계 결정을 모듈 내부로 감추고 인터페이스 제공
        - **보통 은 데이터가 비밀 ← 하향식 기능 분해와 달리 데이터 중심 ⇒ 데이터와 함수가 통합된 한차원 높은 추상화**
        - c - external , java -pakage , c++ - namespace
    - 장점 -
        - 변경 시 모듈 내부에만 영향
        - 비즈니스 로직과 사용자 인터페이스에 대한 관심사 분리
        - 전역변수,전역함수 제거로 네임스페이스 오염 방지 - 이름충돌 완화
        - 각 모듈은 외부에 감춰야하는 비밀과 관련성 높은 데이터와 함수의 집합 → 모듈 내부는 높은 응집도, 모듈 끼리 통신은 퍼블릭 인터페이스로 → 낮은 결합도
    - 단점 -변경을 관리하기 위한 구현 기법이기 떄문에 추상화 관점에서의 한계점 존재
        - 인스턴스 개념 제공 x → 추상테이터타입 등장

[데이터 추상화와 추상 데이터 타입]

- 타입 : 변수에 저장할 수 있는 내용물의 종류, 변수에 적용될 수 있는 연산의 가짓수
- 데이터 추상화 : 프로시저 추상화를 보완하기 위해 제안, 추상데이터 타입은 추상객체의 크랠스를 정의한것으로 추상객체에 사용할 수 있는 오퍼레이션을 이용해 규정, 객체가 외부에 제공하는행위에만 관심을 가지고 구현은 무시
    - 추상 데이터 타입 구현을 위한 프로그래밍 언어의 지원 필요
        - 타입정의 선언
        - 타입의 인스턴스를 다루기 위해 오퍼레이션의 집합 정의
        - 제공된 오퍼레이션으 ㄹ통해서만 조작하여 데이터를 외부로부터 보호
        - 타입에 대해 여러개의 인스턴스 생성
    - 객체 생성은 가능하나 데이터와 기느을 분리하여 바라봄. 추상데이터는 시스템의 상태를 저장할 데이터

[클래스]

- 클래스는 상속과 다형성 지원, 추상데이터타입은 데이터 추상화를 기반으로 시스템을 분해 및 은닉할뿐
- 객체지향 프로그래밍과 구분되어 상속과 다형성을 지원하지 않는 추상데이터타입 기반의 프로그래밍 패러다임을 객체기반 프로그래밍이라고 함
    - 추상데이터 타입: 데이터타입 추상화
        - 타입추상화 : 설계의 관점에서 구체적인 직원타입을 외부에 캡슐화(대표타입이 세부타입을 감춤, 오퍼레이션 기준)
        - 타입추상화 기반 기법이 **추상테이터 타입** : **오퍼레이션 기준**. 어떤 직원타입이 있는지 알 수 없음
        - **객체지향**은 **타입을 기준**으로 오퍼레이션을 묶음
            - 공통로직은 어디에? → 부모클래스 → 다형성(동일한 메세지에 서로다르게 반응)
    - 클래스(객체지향) : 절차를 추상화
        - 타입을 기준으로 절차들을 추상화
        - 클래스 내부에 인스턴스의 타입을 표현하는 변수가 있는가
            - 타입변수를 이용한 조건문을 다형성으로 대체 → 변경 시 하나하나 수정해야함 → 개방 폐쇄 원칙 ( 기존코드에 영향없이 새로운 객체유형과 행위 추가 가능) → 확장,변경용이
    - 추상데이터 타입의 접근법을 객체지향 설계에 구현한 것을 데이터 주도 설계라고 함
        - 모듈&추상 데이터 타입 = 데이터중심적 관점
        - 객체지향 = 서비스 중심적 관점
